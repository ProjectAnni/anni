use anni_common::traits::{Decode, Encode};
use std::io::{Cursor, Read};

use crate::{
    codec::{wav::WaveHeader, Decoder, Encoder},
    error::SplitError,
};

/// Split the given input to outputs using breakpoints.
///
/// `Input` must be a [Decoder], such as [crate::codec::FlacCommandDecoder], [crate::codec::wav::WavDecoder], and so on.
/// `Output` is a [Fn] which accepts current `track index`(starting from 0) and returns an [Encoder] to accept the split data.
/// `Breakpoints` is an iterator of [Breakpoint], which can be generated by [crate::cue::cue_breakpoints].
///
/// Here is an example of splitting a wave file to multiple wave files:
/// ```no_run
/// use anni_split::codec::FlacCommandEncoder;
/// use anni_split::codec::wav::WavDecoder;
/// use anni_split::{cue_breakpoints, split};
///
/// let input_wav = "input.wav";
/// let input_cue = "input.cue";
/// let input_cue = anni_common::fs::read_to_string(input_cue).unwrap();
/// let (breakpoints, cue) = cue_breakpoints(&input_cue).unwrap();
///
/// split(
///     WavDecoder(input_wav),
///     |index| {
///         let title = &cue.files[0].tracks[index].title[0];
///         let output = format!("{:02}. {title}.flac", index + 1);
///         Ok(FlacCommandEncoder(output))
///     },
///     breakpoints,
/// )
/// .unwrap()
/// ```
pub fn split<F, E, I, B>(input: impl Decoder, output: F, breakpoints: I) -> Result<(), SplitError>
where
    F: Fn(usize) -> Result<E, SplitError>,
    E: Encoder,
    I: IntoIterator<Item = B>,
    B: Breakpoint,
{
    let mut reader = &mut input.decode()?;
    let header = WaveHeader::from_reader(&mut reader)?;

    let mut start = 0u32;

    for (index, end) in breakpoints
        .into_iter()
        .map(|b| b.position(&header))
        .chain([header.data_size])
        .enumerate()
    {
        let encoder = output(index)?;
        let size = end - start;

        let mut header_buf = Cursor::new([0; 44]);
        let mut header = header.clone();
        header.data_size = size;
        header.write_to(&mut header_buf)?;
        header_buf.set_position(0);

        let body = &mut reader.take(size as u64);
        encoder.encode(header_buf.chain(body))?;

        start = end;
    }

    Ok(())
}

pub trait Breakpoint {
    fn position(&self, header: &WaveHeader) -> u32;
}

pub struct RawBreakpoint(pub u32);

impl Breakpoint for RawBreakpoint {
    fn position(&self, _: &WaveHeader) -> u32 {
        self.0
    }
}

#[cfg(test)]
mod tests {
    use crate::codec::wav::WavDecoder;
    use crate::codec::FlacCommandEncoder;
    use crate::cue::cue_breakpoints;
    use crate::split;

    #[test]
    fn test_split_a_cd() {
        let input_wav =
            "/home/yesterday17/音乐/ostella/終のステラ豪華限定版同梱OriginalSoundTrack.wav";
        let input_cue =
            "/home/yesterday17/音乐/ostella/終のステラ豪華限定版同梱OriginalSoundTrack.cue";
        let input_cue = anni_common::fs::read_to_string(input_cue).unwrap();

        let (breakpoints, cue) = cue_breakpoints(&input_cue).unwrap();
        split(
            WavDecoder(input_wav),
            |index| {
                let title = &cue.files[0].tracks[index].title[0];
                let output = format!(
                    "/home/yesterday17/音乐/ostella/{:02}. {title}.flac",
                    index + 1
                );
                Ok(FlacCommandEncoder(output))
            },
            breakpoints,
        )
        .unwrap()
    }
}
